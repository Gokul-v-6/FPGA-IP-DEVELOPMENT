# SPI MASTER IP - MODE 0
---
## 1. Introduction
This project implements a minimal SPI Master IP supporting 8-bit transfers in SPI Mode 0.
The SPI IP is memory-mapped and integrated into a simple RV32-based SoC along with GPIO
and UART peripherals.

The design focuses on clarity, correctness, and end-to-end validation from software
to hardware.

---
## 2. SPI Basics

SPI (Serial Peripheral Interface) is a synchronous serial communication protocol
commonly used to connect microcontrollers with peripherals such as sensors,
ADCs, DACs, and flash memory.

SPI uses four main signals:
- SCLK  : Serial Clock (driven by master)
- MOSI  : Master Out, Slave In
- MISO  : Master In, Slave Out
- CS_N  : Chip Select (active low)
<img width="1071" height="323" alt="image" src="https://github.com/user-attachments/assets/f004b708-a06c-4cac-ad85-15d8bd13f70d" />


SPI is a full-duplex protocol where data is shifted serially, one bit per clock cycle.

---
## 3. SPI Mode 0 Operation

SPI Mode 0 is defined by:
- CPOL = 0 → Clock idle state is LOW
- CPHA = 0 → Data is sampled on the rising edge of SCLK
  
<img width="1098" height="641" alt="image" src="https://github.com/user-attachments/assets/66a1b59c-a2c9-463c-b361-1df1cdb84500" />

In Mode 0:
- MOSI is driven on the falling edge of SCLK
- MISO is sampled on the rising edge of SCLK
- CS_N is asserted low at the start of the transfer and deasserted high at the end

The transfer length in this design is fixed at 8 bits.

---

## 4. Register Map

Base Address: 0x00401000

| Offset | Register | Description |
|------|--------|-------------|
| 0x00 | CTRL   | Enable, Start, Clock Divider |
| 0x04 | TXDATA | Transmit data (8-bit) |
| 0x08 | RXDATA | Received data (8-bit) |
| 0x0C | STATUS | BUSY, DONE flags |

CTRL Register:
- Bit 0 : EN (Enable SPI)
- Bit 1 : START (Start transfer)
- Bits [15:8] : CLKDIV (Clock divider)

STATUS Register:
- Bit 0 : BUSY
- Bit 1 : DONE (Write 1 to clear)

TXDATA Register
- Bits [7:0] used; writing loads transmit shift register.

RXDATA Register
- Bits [7:0] contain received byte from last completed transfer

---
## 5. Address Decoding

Each peripheral in the SoC is allocated a dedicated 4 KB address window.

SPI Base Address:
0x00401000 – 0x00401FFF

Address decoding is performed using bits [31:12] of the address bus.
Internal register selection is done using address bits [3:2].

---

## 6. RTL
- [SPI MASTER IP MODULE](RTL/SPI_Module.v)
- Register Write - Updating Control, Data and status registers when SPI address is accessed
<img width="681" height="737" alt="Screenshot 2026-01-06 151219" src="https://github.com/user-attachments/assets/9c254228-20b3-46a7-8e37-0ef24dcd6c56" />

The SPI master is implemented using:
- A finite state machine (FSM)
- Transmit and receive shift registers
- A programmable clock divider
<details>
<summary>  SPI Master FSM (click to expand)  </summary>
  
``` verilog
     else begin
        case(state)
            IDLE:begin sclk<=1'b0;
                        cs_n<=1'b1;
                        busy<=1'b0;
                        if(en && start && ~busy) begin
                            cs_n<=1'b0;
                            busy<=1'b1;
                            clk_cnt<=8'd0;
                            bit<=3'd7;
                            mosi<=tx[7];
                            rx<=0;
                            done<=1'b0;
                            state<=DATA_STATE;
                         end                             
                   end
      DATA_STATE: begin if(clk_cnt == clkdiv)begin
                            clk_cnt<=8'd0;
                            sclk<=~sclk;
                          //Sample MISO at falling eddge according to mode 0  
                            if(sclk == 1'b0)
                                rx<={rx[6:0],miso};
                         //Shift at Rising Edge       
                            else begin 
                                    if(bit != 0) begin
                                        bit<=bit - 1;
                                        mosi<=tx[bit - 1];
                                    end
                                    else state<=DONE;
                            end
                         end
                         else clk_cnt<=clk_cnt + 1;                                                       
                    end
            DONE: begin cs_n<=1'b1;
                        sclk<=1'b0;
                        busy<=1'b0;
                        done<=1'b1;
                        rxdata<=rx;
                        state<=IDLE;
                    end    
         default: state<=IDLE;
        endcase
    end
end
```
</details>
Key features:
- Single-byte (8-bit) transfers
- One transfer at a time
- START bit triggers a transfer
- BUSY and DONE status flags
- Write-1-to-clear DONE flag

The SPI clock is generated by dividing the system clock.SCLK toggles every (CLKDIV+1) cycles
<details>
<summary>SCLK GENERATOR WITH CLOCK DIVIDER (click to expand)</summary>

### MODE 0 operation

- MOSI is driven on the falling edge of SCLK
- MISO is sampled on the rising edge of SCLK
<img width="571" height="213" alt="image" src="https://github.com/user-attachments/assets/4a5337f5-9d0b-4b27-8048-87e5b936081c" />



``` verilog
DATA_STATE: begin if(clk_cnt == clkdiv)begin
                            clk_cnt<=8'd0;
                            sclk<=~sclk;

```
</details>

---
## 7. SoC Integration
- [TOP MODULE](RTL/riscv.v)
- Added SPI Signals in SoC Netlist
  <img width="401" height="334" alt="image" src="https://github.com/user-attachments/assets/3cb9895f-58bf-42b4-9297-df7257540d13" />

- Instantiating SPI Module in SoC
<img width="454" height="385" alt="image" src="https://github.com/user-attachments/assets/2dbbd281-a0a8-4efd-a8b5-bc04074864ba" />

- Updated Read MUX
<img width="969" height="126" alt="image" src="https://github.com/user-attachments/assets/47209438-c55e-4a8f-8d97-b88e40cdc127" />

---
## 8. Testbench & Verification
- [Test bench](RTL/tb_soc.v)
- [SPI_MASTER.c](Firmware/SPI_MASTER.c)
  
- The SPI Master IP is verified using a C firmware test running on the RV32 CPU.
The program configures the SPI controller, transmits a known byte, polls the
DONE status flag, and reads back the received data. In loopback mode, correct
operation is confirmed when transmitted and received values match.


A Verilog testbench is used to verify the SPI master.

Verification strategy:
- MISO is looped back to MOSI
- TXDATA = 0xA5 is transmitted
- DONE flag is polled
- RXDATA is checked for correctness

The testbench also includes mock models for the iCE40 oscillator and PLL.

### Bits Decoding
- CNTL register
<img width="1267" height="280" alt="image" src="https://github.com/user-attachments/assets/848f6567-e953-4506-bcb8-c50ebfe727ee" />

- TXDATA
<img width="1305" height="239" alt="image" src="https://github.com/user-attachments/assets/288fbad1-3942-4b06-83cd-9d97d0a3c802" />

- SPI signals for One Byte transfer
<img width="1293" height="323" alt="image" src="https://github.com/user-attachments/assets/109fdb4d-3d19-4d80-b5ba-24da89007e17" />

- Validation check
    - Mode 0 operation.
    - One bit Transfer at a time.
    - Successfully updating status registers after completion of one byte transfer.
      
For simulation Clkdivider is taken as 0.

---

## Constrain File
- Assigned the Pins as stated below for SPI signals
<img width="297" height="127" alt="image" src="https://github.com/user-attachments/assets/c52c2311-7a18-480e-9c64-311b8bf42157" />



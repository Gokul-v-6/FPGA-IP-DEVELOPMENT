# SPI MASTER IP - MODE 0
---
## 1. Introduction
This project implements a minimal SPI Master IP supporting 8-bit transfers in SPI Mode 0.
The SPI IP is memory-mapped and integrated into a simple RV32-based SoC along with GPIO
and UART peripherals.

The design focuses on clarity, correctness, and end-to-end validation from software
to hardware.

---
## 2. SPI Basics

SPI (Serial Peripheral Interface) is a synchronous serial communication protocol
commonly used to connect microcontrollers with peripherals such as sensors,
ADCs, DACs, and flash memory.

SPI uses four main signals:
- SCLK  : Serial Clock (driven by master)
- MOSI  : Master Out, Slave In
- MISO  : Master In, Slave Out
- CS_N  : Chip Select (active low)
<img width="1071" height="323" alt="image" src="https://github.com/user-attachments/assets/f004b708-a06c-4cac-ad85-15d8bd13f70d" />


SPI is a full-duplex protocol where data is shifted serially, one bit per clock cycle.

---
## 3. SPI Mode 0 Operation

SPI Mode 0 is defined by:
- CPOL = 0 → Clock idle state is LOW
- CPHA = 0 → Data is sampled on the rising edge of SCLK
  
<img width="1098" height="641" alt="image" src="https://github.com/user-attachments/assets/66a1b59c-a2c9-463c-b361-1df1cdb84500" />

In Mode 0:
- MOSI is driven on the falling edge of SCLK
- MISO is sampled on the rising edge of SCLK
- CS_N is asserted low at the start of the transfer and deasserted high at the end

The transfer length in this design is fixed at 8 bits.

---

## 4. Register Map

Base Address: 0x00401000

| Offset | Register | Description |
|------|--------|-------------|
| 0x00 | CTRL   | Enable, Start, Clock Divider |
| 0x04 | TXDATA | Transmit data (8-bit) |
| 0x08 | RXDATA | Received data (8-bit) |
| 0x0C | STATUS | BUSY, DONE flags |

CTRL Register:
- Bit 0 : EN (Enable SPI)
- Bit 1 : START (Start transfer)
- Bits [15:8] : CLKDIV (Clock divider)

STATUS Register:
- Bit 0 : BUSY
- Bit 1 : DONE (Write 1 to clear)

TXDATA Register
- Bits [7:0] used; writing loads transmit shift register.

RXDATA Register
- Bits [7:0] contain received byte from last completed transfer

---
## 5. Address Decoding

Each peripheral in the SoC is allocated a dedicated 4 KB address window.

SPI Base Address:
0x00401000 – 0x00401FFF

Address decoding is performed using bits [31:12] of the address bus.
Internal register selection is done using address bits [3:2].

---

## 6. RTL
- Register Write - Updating Control, Data and status registers when SPI address is accessed
<img width="681" height="737" alt="Screenshot 2026-01-06 151219" src="https://github.com/user-attachments/assets/9c254228-20b3-46a7-8e37-0ef24dcd6c56" />

The SPI master is implemented using:
- A finite state machine (FSM)
- Transmit and receive shift registers
- A programmable clock divider
<details>
<summary>SPI Master FSM (click to expand)</summary>
  
``` verilog
     else begin
        case(state)
            IDLE:begin sclk<=1'b0;
                        cs_n<=1'b1;
                        busy<=1'b0;
                        if(en && start && ~busy) begin
                            cs_n<=1'b0;
                            busy<=1'b1;
                            clk_cnt<=8'd0;
                            bit<=3'd7;
                            mosi<=tx[7];
                            rx<=0;
                            done<=1'b0;
                            state<=DATA_STATE;
                         end                             
                   end
      DATA_STATE: begin if(clk_cnt == clkdiv)begin
                            clk_cnt<=8'd0;
                            sclk<=~sclk;
                          //Sample MISO at falling eddge according to mode 0  
                            if(sclk == 1'b0)
                                rx<={rx[6:0],miso};
                         //Shift at Rising Edge       
                            else begin 
                                    if(bit != 0) begin
                                        bit<=bit - 1;
                                        mosi<=tx[bit - 1];
                                    end
                                    else state<=DONE;
                            end
                         end
                         else clk_cnt<=clk_cnt + 1;                                                       
                    end
            DONE: begin cs_n<=1'b1;
                        sclk<=1'b0;
                        busy<=1'b0;
                        done<=1'b1;
                        rxdata<=rx;
                        state<=IDLE;
                    end    
         default: state<=IDLE;
        endcase
    end
end
```
Key features:
- Single-byte (8-bit) transfers
- One transfer at a time
- START bit triggers a transfer
- BUSY and DONE status flags
- Write-1-to-clear DONE flag

The SPI clock is generated by dividing the system clock.SCLK toggles every (CLKDIV+1) cycles
<details>
<summary>SCLK GENERATOR WITH CLOCK DIVIDER (click to expand)</summary>
  
``` verilog
DATA_STATE: begin if(clk_cnt == clkdiv)begin
                            clk_cnt<=8'd0;
                            sclk<=~sclk;

```

---
## 7. Testbench & Verification

A Verilog testbench is used to verify the SPI master.

Verification strategy:
- MISO is looped back to MOSI
- TXDATA = 0xA5 is transmitted
- DONE flag is polled
- RXDATA is checked for correctness

The testbench also includes mock models for the iCE40 oscillator and PLL.



